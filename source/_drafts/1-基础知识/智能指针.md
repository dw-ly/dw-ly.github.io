讲解文章：https://blog.csdn.net/flowing_wind/article/details/81301001

demo文章：https://blog.csdn.net/m0_45867846/article/details/107115840?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-4.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-4.no_search_link

1.分类

```c++
shared_ptr<T> p1;//允许多个指针指向同一个对象
unique_ptr<T> p2;//独占所指对象
```

2.简单使用

使用make_shared初始化比较好

```c++
shared_ptr<int> p1 = make_shared<int>();
cout << "p1 count:" << p1.use_count() << endl;
shared_ptr<int> p2 = make_shared<int>();
cout << "p2 count:" << p2.use_count() << endl;
p1 = p2;
cout << "after p1 = p2 p2 count:" << p2.use_count() << endl;
```

使用注意事项

https://www.jianshu.com/p/d304cfa56ca0



weak_ptr

https://blog.csdn.net/albertsh/article/details/82286999





**shared_ptr 空对象**

https://www.zhihu.com/question/300012580?sort=created



示例:

```c++
#include <iostream>
#include <memory>

using namespace std;
struct test
{
        int a;
        test(int i):a(i){printf("test()\n");}
        ~test(){printf("~test()\n");}
};
void shar(int i)
{       
        test t(i);
        shared_ptr<test> tem = make_shared<test>(t);
        shared_ptr<test> tem2 = make_shared<test>(t);
        auto tt = tem;
        printf("1.tem:%d use_count:%ld\n", tem.get()->a, tem.use_count());
        auto tt2 = tem;
        printf("2.tem:%d use_count:%ld\n", tem.get()->a, tem.use_count());
        //auto ttt = tem2;
        //printf("3.tem2:%d use_count:%ld\n", tem2.get()->a, tem2.use_count());
        auto ttt2 = tem2;
        printf("4.tem2:%d use_count:%ld\n", tem2.get()->a, tem2.use_count());
        tem = tem2;//在赋值操作中, 原来资源的引用计数会减一，新指向的资源引用计数会加一。
        auto tt1 = tem;
        printf("tem:%d use_count:%ld\n", tem.get()->a, tem.use_count());
        printf("tem2:%d use_count:%ld\n", tem2.get()->a, tem2.use_count());
        printf("tt:%d use_count:%ld\n", tt.get()->a, tt.use_count());
}
int main()
{
	//for(int i = 0;i < 3;i++)
	shar(1);
}
```





理解使用场景

智能指针的目标是“自动内存管理”，它本身是一个在栈上分配的对象，但里面的内容是在堆上，有那么一点绕。

当你需要一个生命周期有限，又得“动态”在堆上创建的时候，就用unique_ptr。

如果不是动态创建，与堆无关，那显然直接用栈对象更省事，没有了智能指针的成本。

C++对内存管理得太细了，要操心的事情太多。

